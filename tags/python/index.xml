<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Alitux</title><link>https://alitux.com.ar/tags/python/</link><description>Recent content in Python on Alitux</description><generator>Hugo</generator><language>es</language><copyright>Copyleft 2025. Nothing reserved. Feel free to share and share alike.</copyright><lastBuildDate>Sat, 13 Jan 2024 11:19:13 -0300</lastBuildDate><atom:link href="https://alitux.com.ar/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Nombres de Usuarios Únicos en Django</title><link>https://alitux.com.ar/posts/usuarios-unicos-django/</link><pubDate>Sat, 13 Jan 2024 11:19:13 -0300</pubDate><guid>https://alitux.com.ar/posts/usuarios-unicos-django/</guid><description>&lt;p>La creación de nombres de usuarios autogenerados en Django no está implementada por defecto. Es por eso que escribí una simple función, que valiéndose de un CustomUser (No uso User por defecto ya que tengo un modelo personalizado que hereda sus propiedades desde AbstractUser) y tomando como entrada el primer nombre genera nombres de usuarios únicos no predecibles. Si bien no evita ataques por fuerza bruta, mitiga el uso de diccionarios con patrones comunes.&lt;/p></description></item><item><title>Cambiar Título del Tab en Odoo 15</title><link>https://alitux.com.ar/posts/cambiar-titulo-tab-odoo15/</link><pubDate>Mon, 27 Nov 2023 12:19:13 -0300</pubDate><guid>https://alitux.com.ar/posts/cambiar-titulo-tab-odoo15/</guid><description>&lt;p>Una cortita: Para cambiar el título «odoo» que aparece en el tab de Odoo y suponiendo que lo están corriendo en Docker, se debe ejecutar dentro del contenedor de Odoo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sed -i &lt;span class="s1">&amp;#39;s/zopenerp: &amp;#34;Odoo&amp;#34;/zopenerp: &amp;#34;Tunuevotitulo&amp;#34;/&amp;#39;&lt;/span> /usr/lib/python3/dist-packages/odoo/addons/web/static/src/webclient/webclient.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Y si no queremos entrar al contenedor podemos hacer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker &lt;span class="nb">exec&lt;/span> -tiu root sed -i &lt;span class="s1">&amp;#39;s/zopenerp: &amp;#34;Odoo&amp;#34;/zopenerp: &amp;#34;Tunuevotitulo&amp;#34;/&amp;#39;&lt;/span> /usr/lib/python3/dist-packages/odoo/addons/web/static/src/webclient/webclient.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>IMPORTANTE0:&lt;/strong> No olvides en reemplazar Tunuevotitulo por el nombre quieras poner.&lt;/p>
&lt;p>&lt;strong>IMPORTANTE1:&lt;/strong> El cambio que no es permanente, esto quiere decir que si bajamos el contenedor y lo volvemos a levantar se vuelve todo a cero. Para hacer los cambios permanentes podríamos codear un addon o bien exponer toda la carpeta &lt;em>/usr/lib/python3/dist-packages/odoo/addons/web/static/src/webclient&lt;/em> como un volumen, pero no es una buena práctica y no lo sugiero mas que para safar o fines de desarrollo.&lt;/p></description></item><item><title>Parsear texto en Python para MarkdownV2 (API Telegram)</title><link>https://alitux.com.ar/posts/parsear-texto-python-markdownv2-telegram/</link><pubDate>Tue, 07 Nov 2023 10:19:13 -0300</pubDate><guid>https://alitux.com.ar/posts/parsear-texto-python-markdownv2-telegram/</guid><description>&lt;p>Supongamos que se tiene el texto:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">web#id=28&amp;amp;cids=1&amp;amp;menu_id=281&amp;amp;action=415&amp;amp;model=crm.lead&amp;amp;view_type=form
&lt;/code>&lt;/pre>&lt;p>Si uno intentara mandar el texto vía la API de Telegram la API respondería:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;ok&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nt">&amp;#34;error_code&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">400&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nt">&amp;#34;description&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;Bad Request: can&amp;#39;t parse entities: Character &amp;#39;#&amp;#39; is reserved and must be escaped with the preceding &amp;#39;\\&amp;#39;&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto es porque el carácter # es especial y hay que «escaparlo» o decirle a la API que no lo use para formatear texto. Para ello me armé la siguiente función que funciona de primera con todos los caracteres especiales:&lt;/p></description></item></channel></rss>